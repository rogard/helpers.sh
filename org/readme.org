#+title: readme.org
#+author: Erwann Rogard

#+name: doc-lead
#+begin_src org
  This is an Emacs Org meta-file.
#+end_src

* sh
** shared
*** shebang

#+name: sh-shebang
#+begin_src sh
  #!/usr/bin/env bash
#+end_src

*** safer

#+header: :noweb-ref sh-safer
#+begin_src sh
  set -euo pipefail
#+end_src

#+header: :noweb-ref sh-safer
#+begin_src sh
# Reminder:
# `true|false` to be inside a subshell `()` o/w `set -e` will stop execution.
#+end_src

*** variable

#+name: sh-declare-var-else-fallback
#+begin_src sh
  for name in ${array[@]}; do
      fallback_var="fallback_${name}"
      [[ -z "${!name-}" ]] && declare "$name"="${!fallback_var}"
  done
#+end_src

*** function

#+name: sh-fallback-msg-fun
#+begin_src sh
  fallback_msg_fun()
  {
      local msg status symb
      status="$1"
      msg="$2"
      case $status in
      	0) symb=✅;;
      	,*) symb=❌;;
      esac
      printf '%s %s\n' "$symb" "$msg" >&2
  }
#+end_src

#+name: sh-declare-fun-else-fallback
#+begin_src sh
  for name in ${array[@]}; do
      fallback_fun="fallback_${name}"
      if ! declare -F "$name" >/dev/null && declare -F "$fallback_fun" >/dev/null; then
          eval "$(declare -f "$fallback_fun" | sed "s/^$fallback_fun/$name/")"
      fi
  done  
#+end_src

** clone
*** script
:PROPERTIES:
:header-args: :tangle ../sh/er317_clone.sh
:END:

Execute:
~M-x org-narrow-to-subtree~
~M-x org-babel-tangle~
~M-x widen~

**** header

#+header: :noweb-ref sh-clone
#+header: :noweb yes
#+begin_src sh
  <<sh-shebang>>
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  #===============================================================================
  #  er317_clone.sh — clones a given file to a uniquely named file
  #
  #  Author: Erwann Rogard
  #  License: GPL 3.0 (https://www.gnu.org/licenses/gpl-3.0.en.html)
  #
  #  Usage:
  #    ./er317_clone.sh [option] <file>
  #  Option:
  #    --dry-run=true|false
  #    --extension=<extension>
  #  Output
  #    <target file>
  #===============================================================================
#+end_src

**** safer

#+header: :noweb-ref sh-clone
#+header: :noweb yes
#+begin_src sh
  <<sh-safer>>
#+end_src

**** config

#+header: :noweb-ref sh-clone
#+begin_src sh
  # --- CONFIGURATION ------------------------------------------------------------
  fallback_unique_dir="$HOME/unique"
  fallback_unique_log="$HOME/.local/share/unique.log"
  fallback_trash_dir="$HOME/.local/share/Trash/files"
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  array=('unique_dir' 'unique_log' 'trash_dir')
#+end_src

#+header: :noweb-ref sh-clone
#+header: :noweb yes
#+begin_src sh
  <<sh-declare-var-else-fallback>>
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  fallback_recurse_fun() {
      exec "${BASH_SOURCE[0]}" \
  	 --dry-run="$dryrun_flag" \
  	 --extension="$target_ext" \
  	 "$source_file" \
  	 "$@"
  }
  fallback_unique_fun()
  {
      local var
      var=$(mktemp -u)
      echo "${var##*/tmp.}"
  }
#+end_src

#+header: :noweb-ref sh-clone
#+header: :noweb yes
#+begin_src sh
  <<sh-fallback-msg-fun>>
#+end_src

#+header: :noweb-ref sh-clone
#+header: :noweb yes
#+begin_src sh
  # ------------------------------------------------------------------------------
#+end_src

**** set

#+header: :noweb-ref sh-clone
#+begin_src sh
  #  array=('unique_dir' 'unique_log' 'trash_dir')
  array=('unique_dir' 'trash_dir')
#+end_src

#+header: :noweb-ref sh-clone
#+header: :noweb yes
#+begin_src sh
  <<sh-declare-var-else-fallback>>
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  array=('msg_fun' 'recurse_fun' 'unique_fun')
#+end_src

#+header: :noweb-ref sh-clone
#+header: :noweb yes
#+begin_src sh
  <<sh-declare-fun-else-fallback>>
#+end_src

**** option

#+header: :noweb-ref sh-clone
#+begin_src sh
  dryrun_flag='false'
  target_ext=''
  args=()
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  while (( $# > 0 )); do
      case "$1" in
    	--dry-run=*)
  	    dryrun_flag="${1#*=}"
  	    [[ "$dryrun_flag" =~ ^(true|false)$ ]] || {
  		msg_fun "$?" "invalid argument $dryrun_flag"
  		exit 1
  	    }
  	    shift
  	    ;;
          --extension=*)
              target_ext="${1#*=}"
              shift
              ;;
          --*)
  	    echo $(false; msg_fun "$?" "unknown option: $1")
              exit 1
              ;;
    	,*) args+=("$1")
    	   shift
    	   ;;
      esac
  done
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  count="${#args[@]}"
  (( count == 1 )) || {
      msg_fun "$?" $(printf '%s positional arguments' "$count")
      exit 1
  }
  source_file="${args[0]}"
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  if [[ -z "$target_ext" && "$source_file" == *.* ]]
  then
      target_ext="${source_file##*.}"
      recurse_fun "$@" || {
  	msg_fun "$?" "failed to recurse"
  	exit 1
      }
  fi
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  [[ -f "${source_file}" ]] || {
      msg_fun "$?" "$source_file is not a file"
      exit 1
  }
#+end_src

**** main

#+header: :noweb-ref sh-clone
#+begin_src sh
  if [[ ! -d "$unique_dir" ]]; then
      msg='Create unique directory %s? [y/n] '
      read -p "$(printf "$msg" "$unique_dir")" answer
      case "$answer" in
          [yY]*)
              mkdir -p "$unique_dir" || {
  		msg_fun "$?" $(printf 'failed to create directory %s' "$unique_dir")
  		exit 1
  	    }
  	    recurse_fun "$@"
              ;;
          ,*)
              false
              msg_fun "$?" 'Abort'
              exit 1
              ;;
      esac
  fi
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  if [[ ! -f "$unique_log" ]]; then
      msg='Create unique log %s? [y/n] '
      read -p "$(printf "$msg" "$unique_log")" answer
      case "$answer" in
          [yY]*)
              touch "$unique_log" || {
  		msg_fun "$?" $(printf 'failed to create file %s' "$unique_log")
  		exit 1
  	    }
  	    recurse_fun "$@"
              ;;
          ,*)
              false
              msg_fun "$?" 'Abort'
              exit 1
              ;;
      esac
  fi
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  target_file="${unique_dir%/}/"
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  target_file+=$(unique_fun)
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  [[ -z "${target_ext}" ]] || {
      target_file+=".${target_ext}"
  }
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  # --- SIDE EFFECT --------------------------------------------------------------
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  msg_format=$(printf 'copy %s to %s' "$source_file" "$target_file")  
  [[ "$dryrun_flag" == 'true' ]] \
      || cp "$source_file" "$target_file" \
      || {
  	msg_fun "$?" "$msg_format"
  	exit 1;
      }
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  msg_format=$(printf 'move %s to %s' "$source_file" "$trash_dir")
  trash_path="${trash_dir%/}/$(basename "$source_file")"
  [[ "$dryrun_flag" == 'true' ]] \
      || mv "$source_file" "${trash_path}" \
      || {
  	msg_fun "$?" "$msg_format"
  	exit 1
      }
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  echo "${target_file}"
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  exit 0
#+end_src

*** test
:PROPERTIES:
:header-args: :tangle ../sh/er317_clone_test.sh
:END:

Execute:
~M-x org-narrow-to-subtree~
~M-x org-babel-tangle~
~M-x widen~

**** header

#+header: :noweb yes
#+begin_src sh
  <<sh-shebang>>
#+end_src

#+begin_src sh
  #===============================================================================
  # er317_clone_test.sh — test for er317_clone.sh
  #
  #  Author: Erwann Rogard
  #  License: GPL 3.0 (https://www.gnu.org/licenses/gpl-3.0.en.html)
  #
  #  Requirement:
  #    Copy `bach.sh` to $PWD
  #  Usage:
  #    source ./er317_clone_test.sh
  #===============================================================================
#+end_src

**** function

#+header: :noweb yes
#+begin_src sh
  <<sh-fallback-msg-fun>>
#+end_src

#+begin_src sh
  array=('msg_fun')
#+end_src

#+header: :noweb yes
#+begin_src sh
  <<sh-declare-fun-else-fallback>>
#+end_src

**** main

#+begin_src sh
  file='bach.sh'
  [[ -f "$file" ]] || {
      msg_fun "$?" "$file not a file"
      exit 1
  }
#+end_src

#+begin_src sh
  source "$file"
#+end_src

#+begin_src sh
  script_dir=$(realpath $(@real dirname "${BASH_SOURCE[0]}"))
#+end_src

#+begin_src sh
  test-clone() {
      temp_dir="$(@real mktemp -d)"
      trap "@real rm -rf '$temp_dir'" EXIT

      source_name='trash.me'
      source_path="$temp_dir/$source_name"
      @real touch "$source_path"
      @real echo "content" > "$source_path"

      export unique_dir="$temp_dir/unique"
      export trash_dir="$temp_dir/trash"

      @real mkdir -p "$unique_dir"
      @real mkdir -p "$trash_dir"

      # Use absolute path to er317_clone.sh relative to this test script
      script_path="${script_dir}/er317_clone.sh"
      target_path=$("$script_path" "$source_path")

      [[ -f "$target_path" ]]; @assert-success
      @assert-equals $(dirname "$target_path") "$unique_dir"
      [[ -f "$source_path" ]]; @assert-fail      
  }
#+end_src

** dnscrypt
:PROPERTIES:
:header-args: :tangle ../sh/er317_dnscrypt.sh
:END:

Execute:
~M-x org-narrow-to-subtree~
~M-x org-babel-tangle~
~M-x widen~

**** header

#+header: :noweb yes
#+begin_src sh
  <<sh-shebang>>
#+end_src

#+begin_src sh
  #===============================================================================
  #  er317_dnscrypt.sh — Toggle DNS resolution through dnscrypt-proxy
  #
  #  Author: Erwann Rogard
  #  License: GPL 3.0 (https://www.gnu.org/licenses/gpl-3.0.en.html)
  #
  #  Config:
  #    Customize variables below
  #
  #  Usage:
  #    ./er317_dnscrypt.sh --enable
  #    ./er317_dnscrypt.sh --disable
  #===============================================================================
#+end_src

**** safer

#+header: :noweb yes
#+begin_src sh
  <<sh-safer>>
#+end_src

**** config

#+begin_src sh
  # --- CONFIGURATION ------------------------------------------------------------
  localhost_ip='127.0.0.1'
  dns_port='53'
  conn_name="ATTh3ecQs2"
  dnscrypt_conf="/etc/dnscrypt-proxy/dnscrypt-proxy.toml"
#+end_src

**** derived

#+begin_src sh
  escaped_ip=${localhost_ip//./\\.}
  pattern="^listen_addresses = \['${escaped_ip}:${dns_port}'\]"
#+end_src

**** sudo


#+begin_src sh
  if (( EUID == 0 )); then
  echo "❌ Script is being run with sudo."
  exit 1
fi
#+end_src

**** function

#+begin_src sh
  check_dnscrypt_binary() {
      if ! command -v dnscrypt-proxy &>/dev/null; then
          echo "❌ error: dnscrypt-proxy binary not found in PATH"
          exit 1
      fi
  }
#+end_src

#+begin_src sh
  check_config() {
      if ! grep -v '^\s*#' "$dnscrypt_conf" | grep -q "$pattern"; then
          echo "❌ error: required setting \`$pattern\` not found in $dnscrypt_conf"
          exit 1
      fi
  }
#+end_src

#+begin_src sh
  check_connection_active() {
      if ! nmcli -t -f NAME,DEVICE connection show --active | grep -q "^$conn_name:"; then
          echo "❌ error: Connection '$conn_name' is not active."
          exit 1
      fi
  }
#+end_src

#+begin_src sh
  modify_dns_settings() {
      local enable=$1
      if (( enable )); then
          sudo nmcli connection modify "$conn_name" ipv4.dns "$localhost_ip"
          sudo nmcli connection modify "$conn_name" ipv4.ignore-auto-dns yes
      else
          sudo nmcli connection modify "$conn_name" ipv4.ignore-auto-dns no
          sudo nmcli connection modify "$conn_name" ipv4.dns ""
      fi
  }
#+end_src

#+begin_src sh
  apply_connection_changes() {
      echo "🔄 Applying network changes to '$conn_name'..."
      device=$(nmcli -t -f DEVICE,STATE device | grep ':connected' | cut -d: -f1 | head -n1)
      if [[ -n "$device" ]]; then
          sudo nmcli device reapply "$device" || {
              echo "⚠️ Failed to reapply connection; falling back to reload."
              sudo nmcli connection reload "$conn_name"
          }
      else
          echo "⚠️ Could not detect active device. Reloading connection config."
          sudo nmcli connection reload "$conn_name"
      fi
  }
#+end_src

#+begin_src sh
  enable_dnscrypt() {
      check_dnscrypt_binary
      check_config
      check_connection_active

      echo "🔧 Enabling dnscrypt-proxy..."

      sudo systemctl enable dnscrypt-proxy || { echo "❌ Failed to enable dnscrypt-proxy"; exit 1; }
      sudo systemctl start dnscrypt-proxy  || { echo "❌ Failed to start dnscrypt-proxy"; exit 1; }

      modify_dns_settings 1
      apply_connection_changes

      echo "✅ DNSCrypt-proxy is now active on '$conn_name'"
  }
#+end_src

#+begin_src sh
  disable_dnscrypt() {
      echo "🔧 Disabling dnscrypt-proxy..."

      sudo systemctl stop dnscrypt-proxy
      sudo systemctl disable dnscrypt-proxy

      modify_dns_settings 0
      apply_connection_changes

      echo "↩️ Reverted DNS settings on '$conn_name'"
  }
#+end_src

#+begin_src sh
  run_checks() {
      echo "💡 Running post-enable checks..."

      echo -n "🔍 Checking listening UDP ports on :53... "
      if sudo ss -lunp | grep -q ':53'; then
          sudo ss -lunp | grep ':53'
      else
          echo "No service listening on port 53 found."
      fi

      echo
      echo "🔍 Testing DNS resolution through dnscrypt-proxy..."
      if dnscrypt-proxy -config "$dnscrypt_conf" -resolve example.com; then
          echo "✅ DNS resolution succeeded."
      else
          echo "❌ DNS resolution failed"
      fi

      echo
      echo "🌐 Opening DNS leak test in your default browser..."
      xdg-open "https://www.dnsleaktest.com" >/dev/null 2>&1 &
  }
#+end_src

**** entry-point

#+begin_src sh
  # --- ENTRYPOINT --------------------------------------------------------------
  case $1 in
      --enable)
          enable_dnscrypt
          run_checks
          ;;
      --disable)
          disable_dnscrypt
          ;;
      ,*)
          echo "Usage: $0 --enable | --disable"
          exit 1
          ;;
  esac
#+end_src
