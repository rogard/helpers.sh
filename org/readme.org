#+title: readme.org
#+author: Erwann Rogard

#+name: doc-lead
#+begin_src org
  This is an Emacs Org meta-file.
#+end_src

* sh
** shared
*** shebang

#+name: sh-shebang
#+begin_src sh
  #!/usr/bin/env bash
#+end_src

*** safer

#+header: :noweb-ref sh-safer
#+begin_src sh
  set -euo pipefail
#+end_src

#+header: :noweb-ref sh-safer
#+begin_src sh
# Reminder:
# `true|false` to be inside a subshell `()` o/w `set -e` will stop execution.
#+end_src

*** variable

#+name: sh-declare-var-else-fallback
#+begin_src sh
  for name in ${array[@]}; do
      fallback_var="fallback_${name}"
      [[ -z "${!name-}" ]] && declare "$name"="${!fallback_var}"
  done
#+end_src

*** function

#+name: sh-fallback-msg-fun
#+begin_src sh
  fallback_msg_fun()
  {
      local msg status symb
      status="$1"
      msg="$2"
      case $status in
      	0) symb=✅;;
      	,*) symb=❌;;
      esac
      printf '%s %s\n' "$symb" "$msg" >&2
  }
#+end_src

#+name: sh-declare-fun-else-fallback
#+begin_src sh
  for name in ${array[@]}; do
      fallback_fun="fallback_${name}"
      if ! declare -F "$name" >/dev/null && declare -F "$fallback_fun" >/dev/null; then
          eval "$(declare -f "$fallback_fun" | sed "s/^$fallback_fun/$name/")"
      fi
  done  
#+end_src

** clone
*** script
:PROPERTIES:
:header-args: :tangle ../sh/er317_clone.sh
:END:

Execute:
~M-x org-narrow-to-subtree~
~M-x org-babel-tangle~
~M-x widen~

**** header

#+header: :noweb-ref sh-clone
#+header: :noweb yes
#+begin_src sh
  <<sh-shebang>>
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  #===============================================================================
  #  er317_clone.sh — clones a given file to a uniquely named file
  #
  #  Author: Erwann Rogard
  #  License: GPL 3.0 (https://www.gnu.org/licenses/gpl-3.0.en.html)
  #
  #  Usage:
  #    ./er317_clone.sh [option] <file>
  #  Option:
  #    --dry-run=true|false
  #    --extension=<extension>
  #  Output
  #    <target file>
  #===============================================================================
#+end_src

**** safer

#+header: :noweb-ref sh-clone
#+header: :noweb yes
#+begin_src sh
  <<sh-safer>>
#+end_src

**** config

#+header: :noweb-ref sh-clone
#+begin_src sh
  # --- CONFIGURATION ------------------------------------------------------------
  fallback_unique_dir="$HOME/unique"
  fallback_unique_log="$HOME/.local/share/unique.log"
  fallback_trash_dir="$HOME/.local/share/Trash/files"
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  array=('unique_dir' 'unique_log' 'trash_dir')
#+end_src

#+header: :noweb-ref sh-clone
#+header: :noweb yes
#+begin_src sh
  <<sh-declare-var-else-fallback>>
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  fallback_recurse_fun() {
      exec "${BASH_SOURCE[0]}" \
  	 --dry-run="$dryrun_flag" \
  	 --extension="$target_ext" \
  	 "$source_file" \
  	 "$@"
  }
  fallback_unique_fun()
  {
      local var
      var=$(mktemp -u)
      echo "${var##*/tmp.}"
  }
#+end_src

#+header: :noweb-ref sh-clone
#+header: :noweb yes
#+begin_src sh
  <<sh-fallback-msg-fun>>
#+end_src

#+header: :noweb-ref sh-clone
#+header: :noweb yes
#+begin_src sh
  # ------------------------------------------------------------------------------
#+end_src

**** set

#+header: :noweb-ref sh-clone
#+begin_src sh
  #  array=('unique_dir' 'unique_log' 'trash_dir')
  array=('unique_dir' 'trash_dir')
#+end_src

#+header: :noweb-ref sh-clone
#+header: :noweb yes
#+begin_src sh
  <<sh-declare-var-else-fallback>>
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  array=('msg_fun' 'recurse_fun' 'unique_fun')
#+end_src

#+header: :noweb-ref sh-clone
#+header: :noweb yes
#+begin_src sh
  <<sh-declare-fun-else-fallback>>
#+end_src

**** option

#+header: :noweb-ref sh-clone
#+begin_src sh
  dryrun_flag='false'
  target_ext=''
  args=()
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  while (( $# > 0 )); do
      case "$1" in
    	--dry-run=*)
  	    dryrun_flag="${1#*=}"
  	    [[ "$dryrun_flag" =~ ^(true|false)$ ]] || {
  		msg_fun "$?" "invalid argument $dryrun_flag"
  		exit 1
  	    }
  	    shift
  	    ;;
          --extension=*)
              target_ext="${1#*=}"
              shift
              ;;
          --*)
  	    echo $(false; msg_fun "$?" "unknown option: $1")
              exit 1
              ;;
    	,*) args+=("$1")
    	   shift
    	   ;;
      esac
  done
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  count="${#args[@]}"
  (( count == 1 )) || {
      msg_fun "$?" $(printf '%s positional arguments' "$count")
      exit 1
  }
  source_file="${args[0]}"
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  if [[ -z "$target_ext" && "$source_file" == *.* ]]
  then
      target_ext="${source_file##*.}"
      recurse_fun "$@" || {
  	msg_fun "$?" "failed to recurse"
  	exit 1
      }
  fi
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  [[ -f "${source_file}" ]] || {
      msg_fun "$?" "$source_file is not a file"
      exit 1
  }
#+end_src

**** main

#+header: :noweb-ref sh-clone
#+begin_src sh
  if [[ ! -d "$unique_dir" ]]; then
      msg='Create unique directory %s? [y/n] '
      read -p "$(printf "$msg" "$unique_dir")" answer
      case "$answer" in
          [yY]*)
              mkdir -p "$unique_dir" || {
  		msg_fun "$?" $(printf 'failed to create directory %s' "$unique_dir")
  		exit 1
  	    }
  	    recurse_fun "$@"
              ;;
          ,*)
              false
              msg_fun "$?" 'Abort'
              exit 1
              ;;
      esac
  fi
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  if [[ ! -f "$unique_log" ]]; then
      msg='Create unique log %s? [y/n] '
      read -p "$(printf "$msg" "$unique_log")" answer
      case "$answer" in
          [yY]*)
              touch "$unique_log" || {
  		msg_fun "$?" $(printf 'failed to create file %s' "$unique_log")
  		exit 1
  	    }
  	    recurse_fun "$@"
              ;;
          ,*)
              false
              msg_fun "$?" 'Abort'
              exit 1
              ;;
      esac
  fi
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  target_file="${unique_dir%/}/"
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  target_file+=$(unique_fun)
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  [[ -z "${target_ext}" ]] || {
      target_file+=".${target_ext}"
  }
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  # --- SIDE EFFECT --------------------------------------------------------------
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  msg_format=$(printf 'copy %s to %s' "$source_file" "$target_file")  
  [[ "$dryrun_flag" == 'true' ]] \
      || cp "$source_file" "$target_file" \
      || {
  	msg_fun "$?" "$msg_format"
  	exit 1;
      }
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  msg_format=$(printf 'move %s to %s' "$source_file" "$trash_dir")
  trash_path="${trash_dir%/}/$(basename "$source_file")"
  [[ "$dryrun_flag" == 'true' ]] \
      || mv "$source_file" "${trash_path}" \
      || {
  	msg_fun "$?" "$msg_format"
  	exit 1
      }
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  echo "${target_file}"
#+end_src

#+header: :noweb-ref sh-clone
#+begin_src sh
  exit 0
#+end_src

*** test
:PROPERTIES:
:header-args: :tangle ../sh/er317_clone_test.sh
:END:

Execute:
~M-x org-narrow-to-subtree~
~M-x org-babel-tangle~
~M-x widen~

**** header

#+header: :noweb yes
#+begin_src sh
  <<sh-shebang>>
#+end_src

#+begin_src sh
  #===============================================================================
  # er317_clone_test.sh — test for er317_clone.sh
  #
  #  Author: Erwann Rogard
  #  License: GPL 3.0 (https://www.gnu.org/licenses/gpl-3.0.en.html)
  #
  #  Requirement:
  #    Copy `bach.sh` to $PWD
  #  Usage:
  #    source ./er317_clone_test.sh
  #===============================================================================
#+end_src

**** function

#+header: :noweb yes
#+begin_src sh
  <<sh-fallback-msg-fun>>
#+end_src

#+begin_src sh
  array=('msg_fun')
#+end_src

#+header: :noweb yes
#+begin_src sh
  <<sh-declare-fun-else-fallback>>
#+end_src

**** main

#+begin_src sh
  file='bach.sh'
  [[ -f "$file" ]] || {
      msg_fun "$?" "$file not a file"
      exit 1
  }
#+end_src

#+begin_src sh
  source "$file"
#+end_src

#+begin_src sh
  script_dir=$(realpath $(@real dirname "${BASH_SOURCE[0]}"))
#+end_src

#+begin_src sh
  test-clone() {
      temp_dir="$(@real mktemp -d)"
      trap "@real rm -rf '$temp_dir'" EXIT

      source_name='trash.me'
      source_path="$temp_dir/$source_name"
      @real touch "$source_path"
      @real echo "content" > "$source_path"

      export unique_dir="$temp_dir/unique"
      export trash_dir="$temp_dir/trash"

      @real mkdir -p "$unique_dir"
      @real mkdir -p "$trash_dir"

      # Use absolute path to er317_clone.sh relative to this test script
      script_path="${script_dir}/er317_clone.sh"
      target_path=$("$script_path" "$source_path")

      [[ -f "$target_path" ]]; @assert-success
      @assert-equals $(dirname "$target_path") "$unique_dir"
      [[ -f "$source_path" ]]; @assert-fail      
  }
#+end_src
