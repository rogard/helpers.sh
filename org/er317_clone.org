#+title: er317_clone.org
#+author: Erwann Rogard

#+name: doc-lead
#+begin_src org
  This is a meta-file for =er317_clone.sh= and related files.
#+end_src

* sh
** shared

#+name: sh-shebang
#+begin_src sh
  #!/usr/bin/env bash
#+end_src

** clone
*** script
:PROPERTIES:
:header-args: :tangle ../sh/er317_clone.sh
:END:

Execute:
~M-x org-narrow-to-subtree~
~M-x org-babel-tangle~
~M-x widen~

**** header

#+header: :noweb-ref sh-header
#+begin_src sh
  <<sh-shebang>>
#+end_src

#+header: :noweb-ref sh-header
#+begin_src sh
  #===============================================================================
  #  er317_clone.sh — clones a given file to a uniquely named file
  #
  #  Author: Erwann Rogard
  #  License: GPL 3.0 (https://www.gnu.org/licenses/gpl-3.0.en.html)
  #
  #  Usage:
  #    ./er317_clone.sh [option] <file>
  #  Option:
  #    --dry-run=true|false
  #    --extension=<extension>
  #  Output
  #    <target file>
  #===============================================================================
#+end_src

**** safer

#+header: :noweb-ref sh-safer
#+begin_src sh
  set -euo pipefail
#+end_src

#+header: :noweb-ref sh-safer
#+begin_src sh
# Reminder:
# `true|false` to be inside a subshell `()` o/w `set -e` will stop execution.
#+end_src

**** config

#+name: sh-config
#+begin_src sh
  # --- CONFIGURATION ------------------------------------------------------------
  fallback_unique_dir="$HOME/unique"
  fallback_unique_log="$HOME/.local/share/unique.log"
  fallback_trash_dir="$HOME/.local/share/Trash/files"
  fallback_msg_fun()
  {
      local msg status symb
      status="$1"
      msg="$2"
      case $status in
      	0) symb=✅;;
      	,*) symb=❌;;
      esac
      printf '%s %s\n' "$symb" "$msg" >&2
  }
  fallback_recurse_fun() {
      exec "${BASH_SOURCE[0]}" \
  	 --dry-run="$dryrun_flag" \
  	 --extension="$target_ext" \
  	 "$source_file" \
  	 "$@"
  }
  fallback_unique_fun()
  {
      local var
      var=$(mktemp -u)
      echo "${var##*/tmp.}"
  }
  # ------------------------------------------------------------------------------
#+end_src

#+header: :noweb-ref sh-main
#+begin_src sh
  for name in msg_fun recurse_fun unique_fun; do
      fallback_fun="fallback_${name}"
      if ! declare -F "$name" >/dev/null && declare -F "$fallback_fun" >/dev/null; then
          eval "$(declare -f "$fallback_fun" | sed "s/^$fallback_fun/$name/")"
      fi
  done
#+end_src

**** option

#+header: :noweb-ref sh-main
#+begin_src sh
  dryrun_flag='false'
  target_ext=''
  args=()
#+end_src

#+header: :noweb-ref sh-main
#+begin_src sh
  while (( $# > 0 )); do
      case "$1" in
  	--dry-run=*)
      	    dryrun_flag="${1#*=}"
      	    shift
      	    ;;
        	--extension=*)
        	    target_ext="${1#*=}"
        	    shift
        	    ;;
        	--*) 
      	    echo $(false; msg_fun "$?" "unknown option: $1")
        	    exit 1
        	    ;;
  	,*) args+=("$1")
  	   shift
  	   ;;
      esac
  done
#+end_src

#+header: :noweb-ref sh-main
#+begin_src sh
  (( "${#args[@]}" == 1 )) || {
      msg_fun "$?" "$(printf '%s positional arguments' "$count")"
      exit 1
  }
  source_file="${args[0]}"
#+end_src

#+header: :noweb-ref sh-main
#+begin_src sh
  if [[ -z "$target_ext" && "$source_file" == *.* ]]
  then
      target_ext="${source_file##*.}"
      recurse_fun "$@" || {
  	msg_fun "$?" "failed to recurse"
  	exit 1
      }
  fi
#+end_src

#+header: :noweb-ref sh-main
#+begin_src sh
  [[ -f "${source_file}" ]] || {
      msg_fun "$?" "$source_file is not a file"
      exit 1
  }
#+end_src

**** main

#+header: :noweb-ref sh-main
#+begin_src sh
  for name in unique_dir unique_log trash_dir; do
      fallback_var="fallback_${name}"
      [[ -z "${!name-}" ]] && declare "$name"="${!fallback_var}"
  done
#+end_src

#+header: :noweb-ref sh-main
#+begin_src sh
  if [[ ! -d "$unique_dir" ]]; then
      msg='Create unique directory %s? [y/n] '
      read -p "$(printf "$msg" "$unique_dir")" answer
      case "$answer" in
          [yY]*)
              mkdir -p "$unique_dir" || {
  		msg_fun "$?" $(printf 'failed to create directory %s' "$unique_dir")
  		exit 1
  	    }
  	    recurse_fun "$@"
              ;;
          ,*)
              false
              msg_fun "$?" 'Abort'
              exit 1
              ;;
      esac
  fi
#+end_src

#+header: :noweb-ref sh-main
#+begin_src sh
  if [[ ! -f "$unique_log" ]]; then
      msg='Create unique log %s? [y/n] '
      read -p "$(printf "$msg" "$unique_log")" answer
      case "$answer" in
          [yY]*)
              touch "$unique_log" || {
  		msg_fun "$?" $(printf 'failed to create file %s' "$unique_log")
  		exit 1
  	    }
  	    recurse_fun "$@"
              ;;
          ,*)
              false
              msg_fun "$?" 'Abort'
              exit 1
              ;;
      esac
  fi
#+end_src

#+header: :noweb-ref sh-main
#+begin_src sh
  target_file="${unique_dir%/}/"
#+end_src

#+header: :noweb-ref sh-main
#+begin_src sh
  target_file+=$(unique_fun)
#+end_src

#+header: :noweb-ref sh-main
#+begin_src sh
  [[ -z "${target_ext}" ]] || {
      target_file+=".${target_ext}"
  }
#+end_src

#+header: :noweb-ref sh-main
#+begin_src sh
  # --- SIDE EFFECT --------------------------------------------------------------
#+end_src

#+header: :noweb-ref sh-main
#+begin_src sh
  msg_format=$(printf 'copy %s to %s' "$source_file" "$target_file")  
  [[ "$dryrun_flag" == 'true' ]] || cp "$source_file" "$target_file"
  status="$?"
  msg_fun "$status" "$msg_format"
  ((status==0)) || { exit 1; }
#+end_src

#+header: :noweb-ref sh-main
#+begin_src sh
  msg_format=$(printf 'move %s to %s' "$source_file" "$trash_dir")
  trash_path="${trash_dir%/}/$(basename "$source_file")"
  [[ "$dryrun_flag" == 'true' ]] || mv "$source_file" "${trash_path}"
  status="$?"
  msg_fun "$status" "$msg_format"
  ((status==0)) || { exit 1; }
#+end_src

#+begin_src sh
  echo "${target_file}"
#+end_src

#+begin_src sh
  exit 0
#+end_src
** test
:PROPERTIES:
:header-args: :tangle ../sh/test_clone.sh
:END:

**** header

#+header: :noweb-ref sh-header
#+begin_src sh
  <<sh-shebang>>
#+end_src

#+header: :noweb-ref sh-header
#+begin_src sh
  #===============================================================================
  #  test_clone.sh — test for er317_clone.sh
  #
  #  Author: Erwann Rogard
  #  License: GPL 3.0 (https://www.gnu.org/licenses/gpl-3.0.en.html)
  #
  #  Usage:
  #    ./test_clone.sh
  #===============================================================================
#+end_src

**** main

#+begin_src sh
  @test "dry-run copy and move with env override for unique_dir and trash_dir" {
  tmpdir=$(mktemp -d)
  trap 'rm -rf "$tmpdir"' EXIT

  script="./your-script.sh"  # ← path to your actual script
  src="$tmpdir/trash.me"
  echo "test content" > "$src"

  # Override fallback paths
  export unique_dir="$tmpdir/unique"
  export unique_log="$tmpdir/unique.log"
  export trash_dir="$tmpdir/trash"

  mkdir -p "$unique_dir"
  mkdir -p "$trash_dir"

  result="$("$script" --dry-run=true --extension=txt "$src")"
  status=$?

  (($status == 0)) || fail "Script exited with status $status"

  echo "$result" | grep -q 'copy' || fail "Expected 'copy' message"
  echo "$result" | grep -q 'move' || fail "Expected 'move' message"

  [[ -f "$src" ]] || fail "Source file should still exist"
  target_file="${result##*$'\n'}"
  [[ ! -f "$target_file" ]] || fail "Dry-run should not create $target_file"
}

#+end_src
