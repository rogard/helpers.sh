#+title: helpers.sh
#+author: Erwann Rogard

#+name: doc-lead
#+begin_src org
  This Emacs Org file contains Unix shell helpers that have passed the test of time in my personal use.
#+end_src

* doc
** license
:PROPERTIES:
:custom_id: doc-license
:END:

#+name: doc-license
#+begin_src org
  #===============================================================================
  #  helpers.sh — Unix shell helpers
  #  Copyright (C) 2024-2025 — Erwann Rogard
  #  Released under GPL 3.0
  #  See https://www.gnu.org/licenses/gpl-3.0.en.html
  #===============================================================================
#+end_src

** requirement
:PROPERTIES:
:custom_id: doc-req
:END:

*** machine
:PROPERTIES:
:custom_id: doc-req-machine
:END:

Installed:
#+name: doc-install
| unix shell |

** workflow
*** setup

Customize these nodes:
#+begin_src elisp
  (org-match-sparse-tree "customize=\"yes\"")
#+end_src

Undo:
#+begin_src elisp
  (org-show-all)
#+end_src

*** tangle

Tangle the source blocks under heading [[id:tangle][tangle]].

*** usage

#+begin_src sh
  source helpers.sh
#+end_src

** reference

Emacs-org:
- [[https://orgmode.org/manual/Working-with-Source-Code.html][Working with source code]]

* source
** elisp
:PROPERTIES:
:evaluate: yes
:END:

#+begin_src emacs-lisp
  (load (expand-file-name "../persemacs/config/extra.el"))
#+end_src

** shell
*** shebang
:PROPERTIES:
:custom_id: source-shebang
:customize: yes
:END:

#+name: sh-shebang
#+begin_src sh
  #!/usr/bin/env bash
#+end_src

#+RESULTS: sh-shebang

*** help

#+name: sh-help
#+header: :noweb-ref sh-source
#+begin_src sh
  #===============================================================================
  # erw_help
  # erw_help <file>
  #===============================================================================
  function erw_help 
  {
      local file pattern string
      file="${1:-${BASH_SOURCE[0]}}"
      pattern='#'
      pattern+=$(printf '=%.0s' {1..81})
      string=$(sed -n "/^${pattern}$/,/^${pattern}$/p" "${file}")
      sed ":a; N; \
  s/\(${pattern}\n\)\(${pattern}\)/\1/; \
    ta; \
    s/\n\{2,\}/\n/; \
    P; D" <<< "${string}"
  }
#+end_src

*** regex
:PROPERTIES:
:custom_id: source-eml
:END:

**** declare

#+header: :session sh-eval
#+header: :noweb-ref sh-source
#+begin_src sh
  declare -A c_erw_regex_ar
#+end_src

#+RESULTS:

**** eml

#+header: :session sh-eval
#+header: :noweb-ref sh-source
#+begin_src sh
  #===============================================================================
  # c_erw_eml_regex_ar
  # c_erw_eml_regex['eml']
  #===============================================================================
#+end_src

#+header: :session sh-eval
#+header: :noweb-ref sh-source
#+begin_src sh
  c_erw_dns_regex_ar=(
      # local             at  sld              tld
      '[[:alnum:]_.%+-]+' '@' '[[:alnum:].-]+' '\.[[:alpha:]]{2,}'
  )
  c_erw_regex_ar['eml']=$(printf '%s' "${c_erw_dns_regex_ar[@]}")
#+end_src

#+RESULTS:

#+header: :session sh-eval
#+header: :noweb-ref sh-example
#+begin_src sh
  test_cases_ar=('john@domain.ext' 'john[At]domain.ext')
  for eml in "${test_cases_ar[@]}"; do
      regex="${c_erw_regex_ar['eml']}"
      [[ "$eml" =~ $regex  ]] || echo "error: $eml"
  done
#+end_src

#+RESULTS:
: error: john[At]domain.ext

**** path

#+header: :session sh-eval
#+header: :noweb-ref sh-source
#+begin_src sh
  #===============================================================================
  # c_erw_regex_ar['path']
  #===============================================================================
  # Xref:
  # https://stackoverflow.com/a/10047501
  # https://stackoverflow.com/a/42036026
  c_erw_regex_ar['path']=('^[^[:cntrl:]]+$')
#+end_src

#+RESULTS:

#+header: :session sh-eval
#+header: :noweb-ref sh-example
#+begin_src sh
  test_cases_ar=(
      "~/user/docs"
      "/tmp/somefile"
      "/path/to/dir/with_subdir"
      "/valid_path_with+characters"
      "/invalid/path/"$'\x01'
      "/another//double/slash"
      "valid/path/without/slash/at/start"
      "/home/user/"$'\0'"path"
  )

  for test_case in "${test_cases_ar[@]}"; do
      if [[ ! "${test_case}" =~ $c_erw_path_regex ]]; then
          echo "Invalid path: ${test_case}"
      fi
  done
#+end_src

#+RESULTS:
: Invalid path: /invalid/path/

*** filesys

**** path
***** join

#+header: :noweb-ref sh-source
#+header: :session sh-eval
#+begin_src sh
  #===============================================================================
  # erw_path_join <parent> <child>
  #===============================================================================
  function erw_path_join
  {
      local parent child result
      parent="${1%/}"
      child="${2#/}"
      result="${parent}/${child}"
      erw_path_p "${result}" \
  	|| {
  	format='%s does not match %s';
  	printf "$format" "$result" "";
  	return 1;
      }
      echo "${result}"
  }
#+end_src

#+RESULTS:

#+header: :session sh-eval
#+header: :noweb-ref sh-example
#+begin_src sh
  test_cases_ar=(
      "/home	user/docs"
      "/home/	user/docs"
      "~/	/user/docs"
  )

  for test_case in "${test_cases_ar[@]}"; do
      parent=$(echo "$test_case" | awk -F$'\t' '{print $1}')
      child=$(echo "$test_case" | awk -F$'\t' '{print $2}')
      erw_path_join "${parent}" "${child}"\
  	|| echo "invalid join between $parent and $child"
  done
#+end_src

#+RESULTS:
| /home/user/docs |
| /home/user/docs |
| ~/user/docs     |

*** predicate
**** exit_ok

#+header: :noweb-ref sh-source
#+begin_src sh
  #===============================================================================
  # erw_exit_ok_p
  #===============================================================================
  function erw_exit_ok_p
  {
      (( $? == 0 ))
  }
#+end_src

*** text
**** fields_count

#+header: :noweb-ref sh-source
#+header: :session sh-eval
#+begin_src sh
  #===============================================================================
  # erw_fields_count <sep> <file>
  #===============================================================================
  function erw_fields_count
  {
      local sep file
      sep="$1"
      file="$2"
      awk -F"$sep" '{print NF}' "$file"
  }
#+end_src

#+header: :noweb-ref sh-example
#+header: :session sh-eval
#+begin_src sh
  temp_file=$(mktemp)
  trap 'rm -f "$temp_file"' EXIT
  cat <<EOF > "$temp_file"
  apple,banana,orange
  dog,cat,mouse
  car,bike,bus,truck
  EOF
  erw_fields_count "," "$temp_file"
#+end_src

#+RESULTS:
| 3 |
| 3 |
| 4 |

*** string
:PROPERTIES:
:custom_id: source-bool
:END:
**** join

#+header: :session sh-eval
#+header: :noweb-ref sh-helper
#+begin_src sh
function erw_string_join {
    local ifs disjunct_ar
    ifs=$1; shift
    disjunct_ar=("${@}")
    (IFS="$ifs"; printf "%s" "${disjunct_ar[*]}")
}
#+end_src

#+RESULTS:

#+header: :session sh-eval
#+header: :noweb-ref sh-example
#+begin_src sh
  test_cases_ar=('foo' 'bar' 'qux')
  regex=$(erw_string_join $'\t' "${test_cases_ar[@]}")

  line='foo'$'\t''bar'$'\t''qux'$'\t'

  [[ "$line" =~ "$regex" ]] || echo "error 1"

  [[ "$line" == "$regex"$'\t' ]] || echo "error 2"
#+end_src

#+RESULTS:

#+begin_src sh
  echo "$IFS"
#+end_src

#+RESULTS:
|   |
|   |

*** tex

TODO
- Put the substitions in an array

#+header: :noweb-ref sh-source
#+header: :session sh-eval
#+begin_src sh
  #===============================================================================
  # erw_tex_safe <string>
  #===============================================================================
  function erw_tex_safe
  {
      local string
      string="${1}"
      echo "${string}" | sed 's/_/\\_/g'
  }
#+end_src

#+RESULTS:

#+header: :noweb-ref sh-example
#+header: :session sh-eval
#+begin_src sh
  erw_tex_safe "john_doe@domain.ext" || echo "error"
#+end_src

#+RESULTS:
: john\_doe@domain.ext

* tangle
:PROPERTIES:
:custom_id: tangle
:header-args: :tangle ./source/helpers.sh
:END:

Do:
- ~M-x org-narrow-to-subtree~
- ~M-x org-babel-tangle~
- ~M-x widen~

#+header: :noweb yes
#+begin_src sh
  <<sh-shebang>>
  <<doc-license()>>
#+end_src

#+header: :noweb yes
#+begin_src sh
  <<sh-preamble>>
  <<sh-source>>
#+end_src

* trash

** hash
:PROPERTIES:
:custom_id: source-hash
:END:

#+name: sh-hash
#+begin_src sh
  #===============================================================================
  # erw_hash <trunc_digit> <string>
  #===============================================================================
  function erw_hash
  {
      local string
      string="$1"
      [[ -z "$string" ]]\
          && { echo "empty string"; return 1; } 
      echo "$string" |  md5sum | cut -d '-' -f1 # | cut -c 1-"$digit"
  }
#+end_src

#+RESULTS: sh-hash

#+header: :session sh-eval
#+header: :noweb-ref sh-example
#+begin_src sh
  erw_hash "foo"
#+end_src

#+RESULTS:
: d3b07384d113edec49eaa6238ad5ff00


